<?php

    // . - любой символ
//   echo preg_replace('#x.x#','!','xax xfx x%x x*x xggx');

//echo preg_replace('#(ab)?a#','!','aa aba abba  aca   aea   abba   adca   abea');

//echo preg_replace('#ab+a#','!','aa   aba   abba  aca   aea   abba   adca   abea');

//Дана строка 'aa aba abba abbba abca abea'. Напишите регулярку,
//которая найдет строки aa, aba, abba, abbba по шаблону: буква 'a',
//буква 'b' любое количество раз (в том числе ниодного раза), буква 'a'.
//echo preg_replace('#ab*a#','!','aa   aba   abba  aca   aea   abba   adca   abea');
//
//3. Дана строка 'aa aba abba abbba abca abea'. Напишите регулярку,
//которая найдет строки aa, aba по шаблону: буква 'a', буква 'b' один
//раз или ниодного, буква 'a'.

//echo preg_replace('#ab?a#','!','aa   aba   abba  aca   aea   abba   adca   abea');


//4. Дана строка 'aa aba abba abbba abca abea'. Напишите регулярку,
//которая найдет строки aa, aba, abba, abbba, не захватив abca abea.

//echo preg_replace('#ab*a#','!','aa   aba   abba  aca   aea   abba   adca   abea');


//5. Дана строка 'ab abab abab abababab abea'. Напишите регулярку,
//которая найдет строки по шаблону: строка 'ab' повторяется 1 или
//более раз.

//echo preg_replace('#(ab)+#','!','ab   abab   abab    abababab   abea');


//На экранировку
//1. Дана строка 'a.a aba aea'. Напишите регулярку, которая найдет
//строку a.a, не захватив остальные.

//echo preg_replace('#a\.a#','!','a.a aba aea');

//2. Дана строка '2+3 223 2223'. Напишите регулярку, которая найдет
//строку 2+3, не захватив остальные.

//echo preg_replace('#2\+3#','!','2+3 223 2223');

//3. Дана строка '23 2+3 2++3 2+++3 345 567'. Напишите регулярку,
//которая найдет строки 2+3, 2++3, 2+++3, не захватив остальные (+
//может быть любое количество).

//echo preg_replace('#2\++3#','!','23 2+3 2++3 2+++3 345 567');

//4. Дана строка '23 2+3 2++3 2+++3 445 677'. Напишите регулярку,
//которая найдет строки 23, 2+3, 2++3, 2+++3, не захватив остальные.

//echo preg_replace('#2\+*3#','!','23 2+3 2++3 2+++3 445 677');


//5. Дана строка '*+ *q+ *qq+ *qqq+ *qqq qqq+'. Напишите регулярку,
//которая найдет строки *q+, *qq+, *qqq+, не захватив остальные.

//echo preg_replace('#\*q+\+#','!','*+ *q+ *qq+ *qqq+ *qqq qqq+');

//6. Дана строка '*+ *q+ *qq+ *qqq+ *qqq qqq+'. Напишите регулярку,
//которая найдет строки *+, *q+, *qq+, *qqq+, не захватив остальные.
//
//echo preg_replace('#\*q*\+#','!','*+ *q+ *qq+ *qqq+ *qqq qqq+');




//На жадность
//1. Дана строка 'aba asdfa asdfswa a12sedda bsdfsdb'. Напишите
//регулярку, которая найдет все строки по краям которых стоят буквы
//'a', не захватив остальные (не захватив bsdfsdb в данном случае).
//Между буквами a может быть любой символ (кроме a).

//echo preg_replace('#a.+?a#','!','aba asdfa asdfswa a12sedda bsdfsdb');


//2. Дана строка '44 4b4 4sdf4 412sedd4 b1234sb'. Напишите регулярку,
//которая найдет все строки по краям которых стоят цифры '4', не
//захватив остальные (не захватив b1234sb в данном случае). Между
//цифрами 4 может быть любой символ (кроме 4) или не быть символа
//вообще.


//echo preg_replace('#4.*?4#','!','44 4b4 4sdf4 412sedd4 b1234sb');



//На {}
//1. Дана строка 'aa aba abba abbba abbbba abbbbba'. Напишите
//регулярку, которая найдет строки abba, abbba, abbbba и только их.

//echo preg_replace('#ab{2,4}a#','!','aa aba abba abbba abbbba abbbbba');


//2. Дана строка 'aa aba abba abbba abbbba abbbbba'. Напишите
//регулярку, которая найдет строки вида aba, в которых 'b' встречается
//менее 3-х раз (включительно).


//echo preg_replace('#ab{1,2}a#','!','aa aba abba abbba abbbba abbbbba');

//3. Дана строка 'aa aba abba abbba abbbba abbbbba'. Напишите
//регулярку, которая найдет строки вида aba, в которых 'b' встречается
//более 4-х раз (включительно).

//echo preg_replace('#ab{4,}a#','!','aa aba abba abbba abbbba abbbbba');





//На \s, \S, \w, \W, \d, \D
//1. Дана строка 'a1a a2a a3a a4a a5a aba aca'. Напишите регулярку,
//которая найдет строки, в которых по краям стоят буквы 'a', а между
//ними одна цифра.

//echo preg_replace('#a\da#','!','a1a a2a a3a a4a a5a aba aca');


//2. Дана строка 'a1a a22a a333a a4444a a55555a aba aca'. Напишите
//регулярку, которая найдет строки, в которых по краям стоят буквы 'a',
//а между ними любое количество цифр.

//echo preg_replace('#a\d+a#','!','aa a1a a22a a333a a4444a a55555a aba aca');

//3. Дана строка 'aa a1a a22a a333a a4444a a55555a aba aca'. Напишите
//регулярку, которая найдет строки, в которых по краям стоят буквы 'a',
//а между ними любое количество цифр (в том числе и ноль цифр, то
//есть строка 'aa').

//echo preg_replace('#a\d*a#','!','aa a1a a22a a333a a4444a a55555a aba aca');

//4. Дана строка 'ave a1a a2a a3a a4a a5a aba aca'. Напишите регулярку,
//которая найдет строки следующего вида: по краям стоят буквы 'a', а
//между ними — не число.

//echo preg_replace('#a\Da#','!','ave  a1a  a2a  a3a  a4a  a5a  aba  aca');

//5. Дана строка 'ave a#a a2a a$a a4a a5a a-a aca'. Напишите регулярку,
//которая найдет строки следующего вида: по краям стоят буквы 'a', а
//между ними — не буква и не цифра .

//echo preg_replace('#a\Wa#','!','ave  a#a  a2a  a$a  a4a  a5a  a-a  aca');

//6. Дана строка 'ave a#a a2a a$a a4a a5a a-a aca'. Напишите регулярку,
//которая найдет все слова (строки, разделенные пробелом).

//echo preg_replace('#\S+#','!','ave  a#a  a2a  a$a  a4a  a5a  a-a  aca');


//На [], '^' - не, [a-zA-Z]
//1. Дана строка 'aba aea aca aza axa'. Напишите регулярку, которая
//найдет строки aba, aea, axa, не затронув остальных.

//echo preg_replace('#a[bex]a#','!','aba aea aca aza axa');


//2. Дана строка 'aba aea aca aza axa a.a a+a a*a'. Напишите регулярку,
//которая найдет строки aba, a.a, a+a, a*a, не затронув остальных.

//echo preg_replace('#a[b.+*]a#','!','aba aea aca aza axa a.a a+a a*a');

//3. Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'a', а между ними — цифра от 3-х до 7-ми.

//echo preg_replace('#a[3-7]a#','!','aba aea aca aza axa a.a a+a a*a');

//4. Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'a', а между ними — буква от a до g.

//echo preg_replace('#a[a-g]a#','!','aba aea aca aza axa a.a a+a a*a');

//5. Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'a', а между ними — буква от a до f и от j до z.

//echo preg_replace('#a[a-fj-z]a#','!','aba aea aca aza axa a.a a+a a*a');

//6. Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'a', а между ними — буква от a до f и от A до Z.

//echo preg_replace('#a[a-fA-Z]a#','!','aba aea aca aza axa a.a a+a a*a');

//7. Дана строка 'aba aea aca aza axa a-a a#a'. Напишите регулярку,
//которая найдет строки следующего вида: по краям стоят буквы 'a', а
//между ними — не 'e' и не 'x'.

//echo preg_replace('#a[^ex]a#','!','aba aea aca aza axa a.a a+a a*a');



//На [a-zA-Z] и квантификаторы
//1. Дана строка 'aAXa aeffa aGha aza ax23a a3sSa'. Напишите
//регулярку, которая найдет строки следующего вида: по краям стоят
//буквы 'a', а между ними — маленькие латинские буквы, не затронув
//остальных.

//echo preg_replace('#a[a-z]+a#u','!','aAXa aeffa aGha aza ax23a a3sSa');

//2. Дана строка 'aAXa aeffa aGha aza ax23a a3sSa'. Напишите
//регулярку, которая найдет строки следующего вида: по краям стоят
//буквы 'a', а между ними — маленькие и большие латинские буквы,
//не затронув остальных.


//echo preg_replace('#a[a-zA-Z]+a#u','!','aAXa aeffa aGha aza ax23a a3sSa');


//3. Дана строка 'aAXa aeffa aGha aza ax23a a3sSa'. Напишите
//регулярку, которая найдет строки следующего вида: по краям стоят
//буквы 'a', а между ними — маленькие латинские буквы и цифры, не
//затронув остальных.

//echo preg_replace('#a[a-z0-9]+a#u','!','aAXa aeffa aGha aza ax23a a3sSa');


//4. Дана строка 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ'.
//Напишите регулярку, которая найдет все слова по шаблону: любая
//кириллическая буква любое количество раз.

//echo preg_replace('#[а-яА-ЯЁё]+#u','!','ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ');




//На '^', '$'
//1. Дана строка 'aaa aaa aaa'. Напишите регулярку, которая заменит
//первое 'aaa' на '!'.

//echo preg_replace('#^aaa#u','!','aaa aaa aaa');

//2. Дана строка 'aaa aaa aaa'. Напишите регулярку, которая заменит
//последнее 'aaa' на '!'.

//echo preg_replace('#aaa$#u','!','aaa aaa aaa');



//На '|'
//1. Дана строка 'aeeea aeea aea bxb bxxb bxxxb'. Напишите регулярку,
//которая найдет строки следующего вида: по краям стоят буквы 'a', а
//между ними — или буква 'e' любое количество раз или по краям
//стоят буквы 'a', а между ними — буква 'x' любое количество раз.


//echo preg_replace('#a(e+|x+)a#u','!','aeeea aeea aea bxb bxxb bxxxb');


//2. Дана строка 'aeeea aeea aea axa axxa axxxa'. Напишите регулярку,
//которая найдет строки следующего вида: по краям стоят буквы 'a', а
//между ними — или буква 'e' два раза или буква 'x' любое количество
//раз.

//echo preg_replace('#a(e{2}|x+)a#u','!','aeeea aeea aea axa axxa axxxa');
//или
//echo preg_replace('#a(ee|x+)a#u','!','aeeea aeea aea axa axxa axxxa');


//На \b, \B
//1. Дана строка 'xbx aca aea abba adca abea'. Напишите регулярку,
//которая разобьет текст на отдельные слова.

//echo preg_replace('#\B#u','!','xbx aca aea abba adca abea');

//На обратный слеш \
//1. Дана строка 'a\a abc'. Напишите регулярку, которая заменит строку
//'a\a' на '!'.

//echo preg_replace('#\\\\#u','!','a\' abc');

//2. Дана строка 'a\a a\\a a\\\a'. Напишите регулярку, которая заменит
//строку 'a\\\a' на '!'.

//echo preg_replace('#a\\\\{3}a#u','!','a\\a a\\\\a a\\\\\\a');

//На экранировку посложнее
//1. Дана строка 'bbb /aaa\ bbb /ccc\'. Напишите регулярку, которая
//найдет содержимое всех конструкций /...\.

//echo preg_replace('#/[a-z]+\\\\#u','!','bbb /aaa\\ bbb /ccc\\');


//2. Дана строка '<b> hello </b>, <b> world </b>'. Напишите регулярку,
//которая найдет содержимое тегов <b>.

//echo preg_replace('#<b>.+?</b>#u','!','<b> hello </b>, <b> world </b>');








//Лекция №3-4-5
//На карманы
//1. Карманы при замене. Дана строка 'aaa@bbb eee7@kkk'. Напишите
//регулярку, которая найдет строки по шаблону: любое количество
//букв и цифр, символ @, любое количество букв и цифр и поменяет
//местами то, что стоит до @ на то, что стоит после нее. Например,
//aaa@bbb должно превратиться в bbb@aaa.

//echo preg_replace('#(\w+)@(\w+)#u','$2@$1--$0--','aaa@bbb eee7@kkk');




//echo preg_replace('#(\w+)&(\w+)#u','$2&$1','xxx&eee  sdf assd&sdfsdf');

//2. Карманы в самой регулярке. Дана строка 'aaa bcd xxx efg'. Найдите
//строки, состоящие из одинаковых символов (это будет aaa xxx).
//3. Несохраняющие скобки (?: … ).Если переданная строка подпадает
//под шаблон 'sdffsf@12234' или 'sdfsdf:::12234', 'sdfsdf::12234': буквы,
//@, цифры или буквы, 2 или 3 двоеточия, цифры, то поменяйте
//местами блок цифр и блок букв.
//Задачи на preg_match[_all] - 1

//echo preg_match_all('#(\w)(a+)(\w)#u','baaab xax sdfaaaasdf', $res);
//var_dump($res);

//1. С помощью preg_match определите, что переданная строка является
//емэйлом. Примеры емэйлов для тестирования mymail@mail.ru,
//my.mail@mail.ru, my-mail@mail.ru, my_mail@mail.ru, mail@mail.com,
//mail@mail.by, mail@yandex.ru.

//echo preg_match('#[\w._-]+@[\w._-]+\.[a-z]{2,5}#u','gfdg my.mail@mail.ru dfgdfg'); // ищет внутри всей строки
//echo preg_match('#^[\w._-]+@[\w._-]+\.[a-z]{2,5}$#u','gfdg my.mail@mail.ru dfgdfg'); // ищет только строку

//2. Дана строка с текстом, в котором могут быть емейлы. С помощью
//preg_match_all найдите все емэйлы.

//echo preg_match_all('#[\w._-]+@[\w._-]+\.[a-z]{2,5}#u','mymail@mail.ru,my.mail@mail.ru, my-mail@mail.ru, my_mail@mail.ru, mail@mail.com, mail@mail.by, mail@yandex.ru', $res);
//var_dump($res);

//3. С помощью preg_match определите, что переданная строка является
//доменом. Примеры доменов: site.ru, site.com, my-site.com.

//echo preg_match('#[\w-]+\.[a-z]{2,}#u','site.ru');


//4. С помощью preg_match определите, что переданная строка является
//доменом 3-го уровня. Примеры доменов: hello.site.ru, hello.site.com,
//hello.my-site.com.

//echo preg_match('#[\w-]+\.[\w-]+\.[a-z]{2,}#u','hellosite.ru');


//5. С помощью preg_match определите, что переданная строка является
//доменом. Примеры доменов: http://site.ru, http://site.com.

//echo preg_match('#http://[\w.-]+\.[a-z]{2,}#u','http://site.ru');


//6. С помощью preg_match определите, что переданная строка является
//доменом. Протокол может быть как http, так и https.

//echo preg_match('#^https?://[\w.-]+\.[a-z]{2,}$#u','https://site.ru');


//7. С помощью preg_match определите, что переданная строка является
//доменом. Протокол может быть как http, так и https. Домен может
//быть со слешем в конце: http[s]://site.ru, http[s]://site.ru/

//echo preg_match('#^https?://[\w.-]+\.[a-z]{2,}/?$#u','https://site.ru/');

//8. С помощью preg_match определите, что переданная строка
//начинается с http или с https.

//echo preg_match('#^https?#u','https://site.ru/');

//9. С помощью preg_match определите, что переданная строка
//заканчивается расширением txt, html или php.

//echo preg_match('#\.(txt|html?|php)$#u','index.html');


//10. С помощью preg_match определите, что переданная строка
//заканчивается расширением txt, html или php. Учтите то, что файл
//может иметь несколько точек внутри, например, так: file.php.txt или
//file.txt.php. В первом случае расширение txt, во втором — php.


//echo preg_match('#\.(txt|html?|php)$#u','index.html');


//11. С помощью preg_match определите, что переданная строка
//заканчивается расширением jpg или jpeg.

//echo preg_match('#\.jpe?g$#u','1.jpeg');


//12. Дана строка с тегами 'text <b> bold1 </b> text <b> bold2 </b>'.
//Найдите содержимое всех тегов '<b>'.

//echo preg_match_all('#<b>(.+?)</b>#u','text <b> bold1 </b> text <b> bold2 </b>', $res);
//var_dump($res);

//Задачи на preg_match[_all] – 2
//1. С помощью preg_match_all преобразуйте дату в формате '31-12-2014'
//в '2014.12.31'.

//echo preg_match('#(\d\d)-(\d\d)-(\d\d\d\d)#u','31-12-2014', $res);
//echo $res[3].'.'.$res[2].'.'.$res[1];
//print_r($res);

//echo preg_match('#(\d\d)(?:-\+)+(\d\d)-(\d\d\d\d)#u','31-+-+-+12-2014', $res); // !!!!!! НЕСОХРАНЯЮЩИЕ СКОБКИ (?:  )
//echo $res[3].'.'.$res[2].'.'.$res[1];
//print_r($res);


//2. С помощью preg_match_all найти строки, сответствующие шаблону:
//YYYY/MM/DD HH:MM:SS.
//
//echo preg_match_all('#\d{4}/\d{2}/\d{2} \d\d:\d\d:\d\d#u','2034/12/34 12:59:59  sdfsdf    2034/12/34 12:35:59', $res);
//var_dump($res);

//3. Дана строка с тегами <img src=”путь”> или <img src='путь'>. С
//помощью preg_match_all создайте массив путей к картинкам.

// \1 - содержимое первого кармана
//echo preg_match_all('#<img src=(["\'])(.+?)\1>#u','<img src="pas1"> <img src=\'pas2\'> <img src="pas3\'>', $res);
//var_dump($res);

//4. Дан урл страницы сайта следующего вида (см. под задачей).
//Положите имя сайта, имя страницы и каждую папку folderN в
//отдельный элемент массива.
//Пример урла: http[s]://site.ru/folder1/.../folderN/page.html или .php.


//echo preg_match('~
//    https?://
//    ([\w.-]+\.\w+)
//    /?
//    (?:
//        (?:
//            (.+)/ #папки
//        )?
//        (
//            [\w.-]+\.(?:php|html|htm)
//        )
//    )?
//    ~ux','http://site.ru', $res);
//$folder = explode('/', $res[2]);
//var_dump($res);
//var_dump($folder);


//5. С помощью preg_match узнайте является ли строка числом, длиной
//до 7 цифр.

//echo preg_match('#\d{1,6}#u','123456');


//6. С помощью preg_match узнайте состоит ли строка только из букв,
//цифр и "_", и ее длина от 5 до 20 символов.

//echo preg_match('#[\w_]{5,20}#u','aer567');



//7. Дана строка с буквами, пробелами и цифрами. Найдите сумму всех
//чисел из данной строки.


//echo preg_match_all('#\d+#u','1 wew 4566', $res);
//$summ = array_sum($res[0]);
//echo $summ;
//var_dump($res);


//8. Дана строка с буквами и с положительными и отрицательными
//числами вида: -2, +3, 3, 3.5, -2.6. Найдите сумму всех чисел из
//строки.
//9. Найдите содержимое всех атрибутов всех тегов в строке. Учтите, что
//атрибуты могут иметь одинарные или двойные кавычки (решите это
//через | и через \1).

//echo preg_match_all('#([\w-]+)\s*=\s*(["\'])(.+?)\2#u','<a href  =  "test">sdfdsf</a>   <p class=\'hello test0\' id="www">sdfsdf</p>  class="eee" <p class="sdf\'>sdf</p>', $res);
//var_dump($res);


//Задачи на preg_replace

//1. С помощью preg_replace замените в строке домены вида http://site.ru,
//http://site.com на <a href=”http://site.ru”>site.ru</a>.

//echo htmlspecialchars(preg_replace('#http://([\w-]+\.[\w-]+)#', '<a href="$0">$1</a>', 'sdfsddf http://site.ru sdfsdf  http://test1.ru'));


//2. С помощью preg_replace замените в строке bb-коды [b] [/b] на теги
//<b> $1 </b>.  sfdgdfg [b] sdfsddf [/b]

echo preg_replace('#\[b\] (.+?) \[/b\]#ux', '<b>$1</b>', 'sfdgdfg [b] sdfsddf [/b] dsadas [b]das[/b] dasd');

//3. Дана строка '23 + 35 ='. Числа могут быть любыми. Выведите на
//экран результат операции в виде '23 + 35 = 58'.


//4. Решите предыдущую задачу с учетом того, что числа могут быть
//дробями вида '2.3 + 3.5'.
//5. Решите предыдущую задачу с учетом того, что вместо плюса могут
//быть знаки -, /, *.
//6. С помощью preg_replace замените все повторяющиеся пробелы на
//один.
//7. Найдите и удалите все комментарии CSS.
//8. Найдите и удалите все комментарии HTML.
//На позитивный и негативный просмотр
//На preg_replace_callback
//1. Дана строка с тегами <img src=”путь” alt=”русский текст”>.
//Замените содержимое тегов alt с русского текста на их странслит.
//Головоломки
//1. Определите, что год находится в интервале от 1900 до 2100 с
//помощью регулярки.
//2. С помощью preg_match определите, что переданная строка является
//корректным временем вида '12:59', '23:41', '00:12', '00:00', '09:15'.
//Время '24.00', '25.00', '12.60', '12.93', '41.93' является некорректным.
//3. С помощью preg_match определите, что переданная строка является
//корректным временем вида '9.59 am', '12.30 pm'.
//4. Написать регулярное выражение определяющее является ли данная
//строчка датой в формате dd/mm/yyyy. Начиная с 1600 года до 9999
//года. День может меняться от 01 до 31, месяц от 01 до 12.
//5. Дано имя файла в операционной системе с путем к нему вида
//'/folder1/folder2/file.exe', '\folder1\folder2\file.exe'. Для windows слеши
//будут обратными \. Расширение файла может быть любым.
//Определите имя файла (в данном случае file) и его расширение (в
//данном случае exe).
//6. В предыдущей задаче определите также путь к файлу:
//'/folder1/folder2/' или '\folder1\folder2\' в нашем примере.
//7. Решите предыдущую задачу при условии того, что в имени файла
//может быть несколько точек: '\folder1\folder2\file.txt.exe'
//8. Преобразовать текст, обрамленный в звездочки, в курсив. Не трогать
//текст в двойных звездочках (жирный). Пример:
//*this is italic*" => <i>this is italic</i>, **text** => **text**.
//Ссылка на задачу и тесты http://callumacrae.github.io/regextuesday/
//challenge4.html.
//9. Проверить, надежно ли составлен пароль. Пароль считается
//надежным, если он состоит из 8 или более символов. Где символом
//может быть английская буква, цифра и знак подчеркивания. Пароль
//должен содержать хотя бы одну заглавную букву, одну маленькую
//букву и одну цифру.
//10. Удалить одной регуляркой все слова из предложения,
//содержащие две одинаковые следующие друг за другом буквы.
//11. Удалить одной регуляркой все повторяющиеся слова из
//предложения, например 'dsf xxx xxx sd' должно вернуть 'dsf xxx sd'.
//12. Решите предыдущую задачу с учетом того, что слово может
//повторяться много раз. Например 'dsf xxx xxx xxx xxx xxx sd'
//должно вернуть 'dsf xxx sd'.
//Головоломки от Callum Macrae (каждый вторник)
//http://callumacrae.github.io/regex-tuesday/
//
//



































//Домашнее задание
//На '.', символы
//1. Дана строка 'xex xfx xaax x4x x%x xbex'. Напишите регулярку,
//которая найдет строки xfx x4x x%x по шаблону: буква 'x', любой
//символ, буква 'x'.
//2. Дана строка 'xbx xcx xex xeerx xsfwx x25vx'. Напишите регулярку,
//которая найдет строки xeerx xsfwx x25vx по шаблону: буква 'x', 3
//любых символа, буква 'x'.
//На '+', '*', '?', ()
//1. Дана строка 'xx x3x x33x x333x x333333x xbex'. Напишите регулярку,
//которая найдет строки по шаблону: буква 'x', цифра '3' любое
//количество раз, буква 'x'.
//2. Дана строка 'xx x3x x33x x333x xasd3x xb33ex'. Напишите регулярку,
//которая найдет строки по шаблону: буква 'x', цифра '3' любое
//количество раз (в том числе ниодного раза), буква 'x'.
//3. Дана строка 'xx x3x x33x x333x x3cx xbex'. Напишите регулярку,
//которая найдет строки xx, xbx по шаблону: буква 'x', цифра '3' один
//раз или ниодного, буква 'x'.
//4. Дана строка 'xx x35x x3x x5x x35cx xbeex'. Напишите регулярку,
//которая найдет строки xx, xbx по шаблону: буква 'x', цифра '3' один
//раз или ниодного, цифра '5' один раз или ниодного, буква 'x'.
//5. Дана строка 'xyz xyzxyz xyzxyzxyz xz'. Напишите регулярку, которая
//найдет строки по шаблону: строка 'xyz' повторяется 1 или более раз.
//На экранировку
//1. Дана строка 'x$x xbx xex'. Напишите регулярку, которая найдет
//строку x$x, не захватив остальные.
//2. Дана строка '6?7 345 3453'. Напишите регулярку, которая найдет
//строку 6?7, не захватив остальные.
//3. Дана строка '23 2?3 2??3 2???3 223 2223'. Напишите регулярку,
//которая найдет строки 2?3 2??3 2???3, не захватив остальные (+
//может быть любое количество).
//4. Дана строка '23 2?3 2??3 2???3 223 2223'. Напишите регулярку,
//которая найдет строки 23 2?3 2??3 2???3, не захватив остальные.
//5. Дана строка '23 2?3 2??3 2???3 223 2223'. Напишите регулярку,
//которая найдет строки 23 2?3, не захватив остальные.
//6. Дана строка '[aa] [aaa] [aaaa] [bbbb]'. Напишите регулярку, которая
//найдет все строки вида: '[', любое количество 'a', ']'
//На жадность
//1. Дана строка 'xbx xs+dfx xs?d34wx x12s#eddx beeeb'. Напишите
//регулярку, которая найдет все строки по краям которых стоят буквы
//'x', не захватив остальные (не захватив beeeb в данном случае).
//Между буквами x может быть любой символ (кроме x).
//2. Дана строка '[a#a][a.aa][aaa a][bbb!b]'. Напишите регулярку, которая
//найдет все строки внутри [] (внутри скобок может быть любой
//символ кроме [ и ]).
//На {}
//1. Дана строка 'xx xex xeex xeeex xeeeex xeeeeex'. Напишите регулярку,
//которая найдет строки xex xeex и только их.
//2. Дана строка 'xx xex xeex xeeex xeeeex xeeeeex'. Напишите регулярку,
//которая найдет строки вида xex, в которых 'e' встречается менее 3-х
//раз (включительно).
//3. Дана строка 'xx xex xeex xeeex xeeeex xeeeeex'. Напишите регулярку,
//которая найдет строки вида xex, в которых 'e' встречается более 4-х
//раз (включительно).
//На \s, \S, \w, \W, \d, \D
//1. Дана строка 'x134x x2334x x32x x4x x12345x xb343x xcx'. Напишите
//регулярку, которая найдет строки, в которых по краям стоят буквы 'x',
//а между ними одна, две или 3 цифры.
//2. Дана строка 'xx x1x x22x x333x x4444x x55555x xbx xcx'. Напишите
//регулярку, которая найдет строки, в которых по краям стоят буквы 'x',
//а между ними одна цифра или вообще ничего.
//3. Дана строка 'x1x x22x x333x x4444x x55555x xbx xcx'. Напишите
//регулярку, которая найдет строки, в которых по краям стоят буквы 'x',
//а между ними любое количество цифр.
//4. Дана строка 'xve x133x x2x x3x xwww3x xwwe$x xbx x###cx'.
//Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'x', а между ними — не число более 3-х раз
//(включительно).
//5. Дана строка 'xve x#x x2x x$x x4x x5x x-x xcx'. Напишите регулярку,
//которая найдет строки следующего вида: по краям стоят буквы 'x', а
//между ними — не буква и не цифра.
//6. Дана строка 'xve x#x x2x x$x x4x x5x x-x xcx'. Напишите регулярку,
//которая найдет все слова (строки, разделенные пробелом).
//На [], '^' - не, [a-zA-Z]
//1. Дана строка 'x+x x.x x*x x(.)x xax xex'. Напишите регулярку, которая
//найдет строки по формату: буква 'x', один из символов '+', '.', '*', 'e',
//буква 'x', не затронув остальных.
//2. Дана строка 'x+x x.x x*x x(.)x xax xex'. Напишите регулярку, которая
//найдет строки по формату: буква 'x', не '+' и не, буква 'x', не затронув
//остальных.
//3. Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'x', а между ними — цифра от 2-х до 5-ми более
//4-х раз включительно.
//4. Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'x', а между ними — буква от b до e любое
//количество раз.
//5. Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'x', а между ними — буква от f до k и от x до z.
//6. Напишите регулярку, которая найдет строки следующего вида: по
//краям стоят буквы 'x', а между ними — буква от a до e и от A до Z,
//а также цифры от 3-х до 9-ти.
//На '^', '$'
//1. Дана строка 'xxx xxx xxx'. Напишите регулярку, которая заменит
//первое 'xxx' на '!'.
//2. Дана строка 'xxx xxx xxx'. Напишите регулярку, которая заменит
//последнее 'xxx' на '!'.
//На '|'
//1. Дана строка 'x777x x555x x444x x555x x666x x333x'. Напишите
//регулярку, которая найдет строки следующего вида: по краям стоят
//буквы 'x', а между ними — или цифра '7' любое количество раз или
//по краям стоят буквы 'x', а между ними — цифра '5' любое
//количество раз.
//2. Дана строка 'xeeex xeex xex xxx xxxx xxxxx xx'. Напишите регулярку,
//которая найдет строки следующего вида: по краям стоят буквы 'x', а
//между ними — или буква 'e' два или три раза или буква 'x' любое
//количество раз (в том числе и ноль раз).
//На обратный слеш \
//1. Дана строка 'x\/\/x abc'. Напишите регулярку, которая заменит строку
//'x\/\/x' на '!'.
//2. Дана строка 'x\x x\\x x\\\x'. Напишите регулярку, которая заменит
//строку 'x\\x' на '!'.
//На экранировку посложнее
//1. Дана строка '<i> hello </i>, <i> world! </i>!'. Напишите регулярку,
//которая найдет содержимое тегов <i>.


//
//echo preg_match_all('#(\w)\1\1#u','dfsg ggg eee sss', $res);
//var_dump($res);